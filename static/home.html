{{define "body"}}
<div class="scroll-progress" id="scrollProgress"></div>

<header class="header">
  <div>
    <h1>National Dishes and BMI</h1>
  </div>

  <div class="sort-toggle">
    <span class="sort-label">Sort:</span>
    <div class="toggle-container">
      <input type="checkbox" id="sortToggle" class="toggle-input" />
      <label for="sortToggle" class="toggle-slider">
        <span class="toggle-option left">◯ → Ⅰ</span>
        <span class="toggle-option right">Ⅰ → ◯</span>
      </label>
    </div>
  </div>
  <a href="/sources">Sources</a>
</header>
<div id="app"></div>

<script>
  let imageObserver = null;
  let revealObserver = null;
  async function initObservers() {
    imageObserver?.disconnect();
    revealObserver?.disconnect();

    const cards = document.querySelectorAll(".card");
    const images = document.querySelectorAll("img[data-src]");
    const imageFrames = document.querySelectorAll(".image-frame");

    const scrollProgress = document.getElementById("scrollProgress");

    function updateScrollProgress() {
      const scrollTop = window.scrollY;
      const docHeight =
        document.documentElement.scrollHeight - window.innerHeight;
      const scrollPercent = (scrollTop / docHeight) * 100;
      scrollProgress.style.height = scrollPercent + "%";
    }
    window.addEventListener("scroll", updateScrollProgress, { passive: true });

    imageFrames.forEach((frame) => frame.classList.add("loading"));
    imageObserver = new IntersectionObserver(
      (entries, obs) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting) {
            const img = entry.target;
            const frame = img.closest(".image-frame");
            img.onload = () => frame.classList.remove("loading");
            img.src = img.dataset.src;
            img.removeAttribute("data-src");
            obs.unobserve(img);
          }
        });
      },
      { rootMargin: "200px" },
    );
    images.forEach((img) => imageObserver.observe(img));

    revealObserver = new IntersectionObserver(
      (entries) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting) {
            entry.target.classList.add("revealed");
            revealObserver.unobserve(entry.target);
          }
        });
      },
      { threshold: 0.1, rootMargin: "0px 0px -30px 0px" },
    );
    cards.forEach((card) => revealObserver.observe(card));
  }

  async function loadContent(reversed = false) {
    const url = reversed ? "/content?sort=rev" : "/content";
    const res = await fetch(url, {
      headers: { "X-Screen-Width": window.innerWidth.toString() },
    });
    if (!res.ok) {
      console.error("failed to get content");
      return;
    }
    document.getElementById("app").innerHTML = await res.text();
    initObservers();
  }

  async function init() {
    await loadContent();

    document.getElementById("sortToggle").addEventListener("change", (e) => {
      loadContent(e.target.checked);
    });

    let currentCols = null;

    function getNumCols(width) {
      if (width > 1400) return 4;
      if (width > 1000) return 3;
      if (width > 600) return 2;
      return 1;
    }

    let resizeTimeout;
    window.addEventListener("resize", () => {
      clearTimeout(resizeTimeout);
      resizeTimeout = setTimeout(() => {
        const newCols = getNumCols(window.innerWidth);
        if (newCols !== currentCols) {
          currentCols = newCols;
          loadContent(sortToggle.checked);
        }
      }, 500);
    });
  }
  init();
</script>
{{end}}
